# -*- coding: utf-8 -*-
"""VMTranslater

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/149YuBX3LzxkjqLsrPPHzxcNJLNiJDAX5

Project7
 vm파일을 asm파일로 변환해 주는 변환기를 만들어준다. 프로젝트 7에서는 stack을 통한 연산과 여러 memory segment을 이용해 push,pop 기능을 구현해 준다.

Pa

Arithmetic:
 Stack에서 피연산값을 가져와 연산 후 다시 Stack에 넣는다.
 Stack은 0번에 StackPointer(SP)를 가지고 memory의 256번 주소부터 값을 가진다.

Memory access:
 Memory segment는 총 8가지(local, argument, this, that, constant, static, temp, pointer)가 있고

Parser:
 vm파일에서 명령어를 가져온 후 이를 code, segment, i로 나누어 저장후 이를 반환한다. 

 1) 이중 local, argument, this, that은 같은 구조를 가지고 각각 segment pointer로 1, 2, 3, 4(LCL, ARG, THIS, THAT)의 주소를 가진다.  

 2)constant는 따로 메모리 영역을 가지지 않고

 3)static은 기존 assembler을 만들었을때 변수를 메모리 주소에 지정해 주는 기능을 만들었는데 이를 활용하여 16번 메모리부터 지정해 준다. 변수명은 static i 에서 i인자를 받아와서 파일명.i로 자동으로 만들어지도록 프로그램한다.

 4)temp는 5번부터 12번까지 8개의 레지스터를 지정해 준다.

 5)pointer segment는 THIS,THAT 레지스터(3번,4번)에 접근하여 이를 stack에 push하거나 pop하는 기능을 구현한다.

Pseudo code


---


Main:


  filename = input()

  create file -> filename.asm
  
  f.open(filename)
  
  for line in filename:
  
    code, segment, i = Parser(line)
  
    CodeWrite.code(segment, i)




---



Parser:
  
  if arithmetic:
  
    code = line[0]
  
    segment = ""
  
    i = -1
  
  elif memory:
  
    code = line[0]
  
    segment = line[1]
  
    i = line[2]
  
    return code, segment, i


---


CodeWrite:
  
    def add():
  
    def sub():
  
    ..
  
    def not():
  
    def push(segment, i):
  
    def pop(segment, i):
"""

fw = open(asm_name, 'w')
fw.write("")
fw.close()

filename = input()

asname = filename.split('.')
asm_name = asname[0]
asm_name = asm_name + ".asm"
fw = open(asm_name, 'w')
fw.close()

#main
index = 0
tablenum = []
tableword = []

fr = open(filename,'r')
for line in fr:
  func = "main"
  if "//" in line:
    spline = line.split("//")
    line = spline[0]
  line = line.rstrip()
  code,segment,i = Parser(line)
  code = code.strip()
  
  if code == "add" or "sub" or "and" or "or" or "eq" or "gt" or "lt" or "not" or "neg":
    CodeWriter.operator(asm_name, code)
  
  if code == "if-goto"or"goto"or"label":
    CodeWriter.branch(asm_name, code, segment, func) 
  
  
  if code == "push":
    CodeWriter.push(asm_name, segment, i)
  elif code == "pop":
    CodeWriter.pop(asm_name, segment, i)
  elif code == "function":
    CodeWriter.function(asm_name, segment, i)
  elif code == "call":
    if segment in tableword:
      index = tableword.index(segment)
      tablenum[index] = str(int(tablenum[index]) + 1)
      count = str(tablenum[index])
    else:
      tablenum.append("0")
      tableword.append(segment)
      count = "0"
    CodeWriter.call(asm_name, segment, i, count)
  elif code == "return":
    CodeWriter.ret(asm_name)
  

fr.close()

"""//빈 asm파일 만들기"""

def Parser(line):
  ps = line.split(" ")
  if len(ps) == 3:
    i = int(ps[2])
    return ps[0], ps[1], i
  elif len(ps) == 2:
    return ps[0], ps[1], -1
  elif len(ps) == 1:
    return ps[0], "", -1
  else:
    return "","",-1

"""//vm코드의 line이 3분할 되면 즉 push나 pop명령어이면 정상적으로 리턴하고
add와 같은 명령어이면 segment와 i값에 각각 null과 -1값을 리턴한다.
"""

class CodeWriter():
  def operator(asm_name, code):
      if code == "add":
        fw = open(asm_name, 'a')
        fw.write("//add\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nM=M+D\n")
        fw.close()
      elif code == "sub":
        fw = open(asm_name, 'a')
        fw.write("//sub\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nM=M-D\n")
        fw.close()
      elif code == "neg":
        fw = open(asm_name, 'a')
        fw.write("//neg\n")
        fw.write("@SP\nA=M-1\nM=-M\n")
        fw.close()
      elif code == "eq":
        fw = open(asm_name, 'a')
        fw.write("//eq\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nD=M-D\n@TRUE\nD;JEQ\n@SP\nA=M-1\nM=0\n@FALSE\n0;JMP\n(TRUE)\n@SP\nA=M-1\nM=-1\n(FALSE)\n")
        fw.close()
      elif code == "gt":
        fw = open(asm_name, 'a')
        fw.write("//gt\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nD=M-D\n@TRUE\nD;JGT\n@SP\nA=M-1\nM=0\n@FALSE\n0;JMP\n(TRUE)\n@SP\nA=M-1\nM=-1\n(FALSE)\n")
        fw.close()
      elif code == "lt":
        fw = open(asm_name, 'a')
        fw.write("//lt\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nD=M-D\n@TRUE\nD;JLT\n@SP\nA=M-1\nM=0\n@FALSE\n0;JMP\n(TRUE)\n@SP\nA=M-1\nM=-1\n(FALSE)\n")
        fw.close()
      elif code == "and":
        fw = open(asm_name, 'a')
        fw.write("//and\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nM=M&D\n")
        fw.close()
      elif code == "or":
        fw = open(asm_name, 'a')
        fw.write("//or\n")
        fw.write("@SP\nAM=M-1\nD=M\nA=A-1\nM=M|D\n")
        fw.close()
      elif code == "not":
        fw = open(asm_name, 'a')
        fw.write("//not\n")
        fw.write("@SP\nA=M-1\nM=!M\n")
        fw.close()
  def push(asm_name,segment, i):
      if segment == "local":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@LCL\nA=M+D\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "argument":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@ARG\nA=M+D\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "this":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@THIS\nA=M+D\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "that":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@THAT\nA=M+D\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "constant":
        i=str(i)
        line = "@"+i+"\nD=A\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line) 
        fw.close()
      elif segment == "static":
        i=str(i)
        ass = asm_name.split('.')
        asm = ass[0]
        asm = asm+"."+i
        line = "@"+asm+"\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line) 
        fw.close()
        
      elif segment == "pointer":
        i=str(i)
        if i == "0":
          line = "@"+"THIS"+"\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        elif i == "1":
          line = "@"+"THAT"+"\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        else:
          return
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" "+i+"\n")
        fw.write(line) 
        fw.close()
      elif segment == "temp":
        fw  = open(asm_name, 'a')
        fw.write("//push "+segment+" %d" %i+"\n")
        i=5+i
        i=str(i)
        line = "@"+i+"\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n"
        fw.write(line) 
        fw.close()
      else:
        return

  def pop(asm_name,segment, i):
      if segment == "local":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@LCL\nD=M+D\n@R13\nM=D\n@SP\nAM=M-1\nD=M\n@R13\nA=M\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//pop "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "argument":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@ARG\nD=M+D\n@R13\nM=D\n@SP\nAM=M-1\nD=M\n@R13\nA=M\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//pop "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "this":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@THIS\nD=M+D\n@R13\nM=D\n@SP\nAM=M-1\nD=M\n@R13\nA=M\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//pop "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "that":
        i=str(i)
        line = "@"+i+"\n"+"D=A\n@THAT\nD=M+D\n@R13\nM=D\n@SP\nAM=M-1\nD=M\n@R13\nA=M\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//pop "+segment+" "+i+"\n")
        fw.write(line)
        fw.close()
      elif segment == "static":
        i=str(i)
        ass = asm_name.split('.')
        asm = ass[0]
        asm = asm+"."+i
        line = "@SP\nAM=M-1\nD=M\n"+"@"+asm+"\nM=D\n"
        fw  = open(asm_name, 'a')
        fw.write("//pop "+segment+" "+i+"\n")
        fw.write(line) 
        fw.close()
        
      elif segment == "pointer":
        i=str(i)
        if i == "0":
          line = "@SP\nAM=M-1\nD=M\n@THIS\nM=D\n"
        elif i == "1":
          line = "@SP\nAM=M-1\nD=M\n@THAT\nM=D\n"
        else:
          return
        fw  = open(asm_name, 'a')
        fw.write("//pop "+segment+" "+i+"\n")
        fw.write(line) 
        fw.close()
      elif segment == "temp":
        fw = open(asm_name, 'a')
        fw.write("//pop "+segment+" %d" %i+"\n")
        i=5+i
        i=str(i)
        line = "@SP\nAM=M-1\nD=M\n"+"@"+i+"\nM=D\n"
        fw.write(line) 
        fw.close()

  def branch(asm_name, code, segment, func):
      if code == "label":
        fw = open(asm_name, 'a')
        fw.write("//label "+segment+"\n")
        segment = segment + "$bar"
        line = "("+segment+")\n"
        fw.write(line)
        fw.close()
      elif code == "if-goto":
        fw = open(asm_name, 'a')
        fw.write("//if-goto "+segment+"\n")
        segment = segment + "$bar"
        line = "@SP\nAM=M-1\nD=M\n@"+segment+"\nD;JNE\n"
        fw.write(line)
        fw.close()
      elif code == "goto":
        fw = open(asm_name, 'a')
        fw.write("//goto "+segment+"\n")
        segment = segment + "$bar"
        line = "@"+segment+"\n0;JMP\n"
        fw.write(line)
        fw.close()

  def function(asm_name, segment, i):
        fw = open(asm_name, 'a')
        i = str(i)
        asn = asm_name.split('.')
        fw.write("//function "+segment+" "+i+"\n")
        line = "("+segment+")\n@"+i+"\nD=A\n(LOOP_"+segment+")\n@FSTART_"+segment+"\nD;JEQ\n@SP\nAM=M+1\nA=A-1\nM=0\nD=D-1\n@LOOP_"+segment+"\n0;JMP\n(FSTART_"+segment+")\n"
        fw.write(line)
        fw.close()

  def call(asm_name, segment, i, count):
        fw = open(asm_name, 'a')
        i = str(i)
        asn = asm_name.split('.')
        fw.write("//call "+segment+" "+i+"\n")
        ret = asn[0]+"."+segment + "$ret." + count
        line = "@" + ret + "\nD=A\n@SP\nAM=M+1\nA=A-1\nM=D\n@LCL\nD=M\n@SP\nAM=M+1\nA=A-1"
        line = line + "\nM=D\n@ARG\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n@THIS\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D"
        line = line + "\n@THAT\nD=M\n@SP\nAM=M+1\nA=A-1\nM=D\n@SP\nD=M\n@5\nD=D-A\n@" + i
        line = line + "\nD=D-A\n@ARG\nM=D\n@SP\nD=M\n@LCL\nM=D\n@"+segment+"\n0;JMP\n("+ret+")\n"
        fw.write(line)
        fw.close()

  def ret(asm_name):
        fw = open(asm_name, 'a')
        fw.write("//return\n")
        line = "@LCL\nD=M\n@5\nM=D\nD=D-A\nA=D\nD=M\n@retAddr\nM=D\n@SP\nAM=M-1\nD=M\n@ARG\nA=M\nM=D\n@ARG\nD=M+1"
        line = line + "\n@SP\nM=D\n@5\nAM=M-1\nD=M\n@THAT\nM=D\n@5\nAM=M-1\nD=M"
        line = line + "\n@THIS\nM=D\n@5\nAM=M-1\nD=M\n@ARG\nM=D\n@5\nAM=M-1\nD=M"
        line = line + "\n@LCL\nM=D\n@retAddr\nA=M\n0;JMP\n"
        fw.write(line)
        fw.close()

def check():
  fr.read

